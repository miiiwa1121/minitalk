# Minitalk

## 目次
- 構成
- 課題条件
- 概要
- 実行
- 使用関数
- メモ
- 質問
  

## Project Structure
```
.
├── Makefile
├── all_libft
│   ├── Makefile
│   ├── include
│   │   ├── ft_printf.h
│   │   ├── get_next_line_bonus.h
│   │   └── libft.h
│   └── src
│       ├── ft_printf
│       ├── gnl
│       └── libft
│           ├── bool_atoi.c
│           ├── error_handler.c
│           └── ft_isspace.c
├── include
│   ├── minitalk.h
│   └── minitalk_bonus.h
└── src
    ├── client.c
    ├── client_bonus.c
    ├── server.c
    └── server_bonus.c

8 directories, 66 files
```

## 課題条件
- サーバーはPIDを表示する
- クライアントは２つのパラメータを受け取る
- 100文字は１秒以内に表示
- 複数クライアントから受信
- ボーナスはメッセージに対して返信する
- ボーナスはユニコード対応

## 概要
```
シグナル通信を利用してクライアントサーバー型のアプリケーションを作る
```
### １．クライアントサーバー型

> それぞれが個別のプロセスとなる２つの実行ファイルを作成
- Makefileで二つの実行ファイルを作成する
> プロセスが分かれているため（シングルプロセスではないため）プロセス間の通信が必要
- 今回はシグナル通信を使用する
- プロセス間通信の方法はシグナルの他にも、`パイプ`,`ソケット通信`,`メッセージキュー`などがある。

### ２．シグナル

- シグナルは64種類あり、`kill -l`で一覧を出力できる
- 今回の課題では、ユーザーに完全に解放されている`(10)SIGUSR1`、`(12)SIGUSR2`のみを利用する。

### ３．シリアル通信的通信
- 二進数の0・1をそれぞれSIGUSR1・SIGUSR2に割り当てて通信する
```
<例>
char型は１バイトで８ビット
const char c = 'A'
A == 0x41(01000001) 
Aを送るにはバイナリを８回１ビットずつ送ればよい。
```

### ４．割り込み

#### クライアント
- 文字を１ビットずつ２種類のシグナルを利用して送信
- kill(システムコール)を利用する

#### サーバー
- シグナルを受け取り、文字を復元する
- signalまたはsigactionを利用する

> ####  signal/sigaction
- 通常シグナルがプロセスに届く(今回の場合はサーバーに届く)とデフォルトアクションが発生し、プロセス終了が実行される。
- このプロセス終了に割り込み、シグナルを横取りする形で別の動作をさせるのがsignal/sigaction。
- sigactionにsignal_handlerを設定することで受け取ったシグナルに応じて元の文字にデコードしていくことができる

### ５．データ欠損の追求
#### 1. signal関数を使ったと時の問題点
- 割り込み中にシグナルが発生すると、割り込みの割り込みが発生し、文字化けが起きる
#### 2. sigactionを使うことで対応する
- SIGUSR1とSIGUSR2の相互の割り込みを禁止できる
#### 3. sigaction関数でも解消されない(割り込み禁止なのに文字化けする)
- ブロックされたシグナルの行方を追う
#### 4. ブロックされたシグナル
- 複数のシグナルが発生し、そのシグナルがブロックされていた(処理待ちシグナルが溜まっていた)場合、ブロック解除後に配送されるのはシグナルひとつだけになる。カーネルではシグナルの待機は一つまでとなっているそう
- 複数のシグナルが処理待ち状態になった場合、配送される順序は不定(SIGUSR1 - SIGUSR2の順でシグナルが送信されてきたとき、一つ目の出力がSIGUSR1になるとは限らない)
> これらのことからシグナルを貯めるのは難しいとわかる。
#### 5. まとめられたシグナル
```
[コラム]
シグナル送信元のpidを調べると０から送られていることがある。
    > これはシグナルがまとめられた時のOSXの不思議な挙動
    > Linuxもまとめられるがpidは一つ目の送信元となる
```
- シグナルはまとめられた時点でデータは欠損してしまう。
>  #### 対策
- sleepを入れてごまかす > 環境や状況によって適正なsleep量が変わる
- bitごとにACKを返信させる > かなり堅牢な通信
```
[堅牢通信]
サーバーは、クライアントに受信したことをビットごとに返事する
クライアントは返事が来たことを確認して次のビットを送信する
```

---

## ビルドとクリーンコマンド
### ビルド
- ビルド: `make`
- ボーナスビルド: `make bonus`

### クリーン
- 中間ファイル削除: `make clean`
- 完全クリーンアップ: `make fclean`

### 再ビルド
- 再ビルド: `make re`

---

## 使用関数
- **`kill`**: 指定されたプロセスにシグナルを送信します。
- **`error_handler`**: プログラム内でエラーが発生した際に処理とメッセージ表示を行う関数。
- **`usleep`**: プログラムの実行を指定時間（マイクロ秒単位）停止します。
- **`getpid`**: 現在のプロセスID（PID）を取得します。
- **`sigemptyset`**: シグナルマスク（シグナルセット）を空に初期化します。
- **`sigaddset`**: シグナルマスクに特定のシグナルを追加します。
- **`sigaction`**: 特定のシグナルを受信した際のハンドラー（動作）を設定します。
- **`pause`**: シグナルを受信するまで待機します。
- **`write`**:標準出力に書き込む
- **`exit`**:プログラムを即座に終了する。
#### オリジナル関数
- **`ft_printf`**:printfの模擬関数
- **`ft_putstr_fd`**:文字列出力
- **`ft_putchar_fd`**:単語出力
- **`bool_atoi`**:変換成功の結果を返し、変換後の値をメモリに格納する

> ### sigemptyset
```
int sigemptyset(sigset_t *set);
```
- set : 初期化するシグナルセット
> ### sigaddset
```
int sigaddset(sigset_t *set, int signum);
```
- set : シグナルセット
- signum : 追加するシグナル（例：SIGINT）
> ### sigaction
```
int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);
```
- signum : 設定するシグナル（例：SIGINT）
- act : 新しい動作
- oldact : 以前の動作を保存（不要なら NULL）
> ### kill
```
int kill(pid_t pid, int sig);
```
- pid : シグナルを送るプロセスのID（getpid() で取得可能）
- sig : 送るシグナル（例：SIGKILL）
> ### getpid
```
pid_t getpid(void);
```
> ### pause
```
int pause(void);
```
> ### usleep
```
int usleep(useconds_t usec);
```
- usec : 待機する時間（マイクロ秒）
> ### exit
```
void exit(int status);
```
- status : 終了コード（0なら正常終了、1以上なら異常終了）

---

## 用語
- **PID**: OSが各プロセスを一意に識別するために割り当てる番号。
- **シグナル**: UNIX/Linux環境でプロセス間通信やイベント通知を行う仕組み。ソフトウェア割り込みとして動作します。
- **システムコール**: ユーザープログラムがOSのカーネル機能を利用するためのインターフェース。例: ファイル操作、プロセス管理、ネットワーク通信。
- **シグナルマスク**: 特定のシグナルを一時的にブロック（受信しないように）する仕組み。
- **シグナルセット**: 複数のシグナルをまとめて管理するデータ構造

---

## メモ
### シグナル
- シグナルは、UNIX/Linuxにおけるソフトウェア割り込みの一種で、プロセス間の通信やシステムからプロセスへの通知に使用されます。例えば、子プロセスの終了通知やエラーの通知などに利用されます。

### システムコール
- システムコールは、ユーザープログラムがOSカーネルのサービスを要求するインターフェースで、ファイルアクセスやプロセス管理、入出力操作を実現します。

### シグナルマスク
- シグナルマスクを使うことで、特定のシグナルを一時的にブロックし、重要なコードが中断されることを防ぎます。

## 構造体
- `struct sigaction`は特定のシグナルを受け取ったときの動作を設定するために使います。（どの関数を実行するか、シグナルを無視するか、デフォルト動作にするか など）
- `sigset` は複数のシグナルをまとめて管理するためのデータ構造です。シグナルのブロックや解除を行うために使われます

```
struct sigaction {
    void (*sa_handler)(int);   /* シグナルハンドラ関数のポインタ */
    void (*sa_sigaction)(int, siginfo_t *, void *); /* 詳細情報を取得できるハンドラ */
    sigset_t sa_mask;          /* シグナルハンドラ実行中にブロックするシグナルのマスク */
    int sa_flags;              /* シグナルハンドラの動作を決定するフラグ */
};
```
```

```

#### フィールドの説明
|フィールド名        |説明|
|-------------------|----|
|sa_handler          |シグナルを受信したときに呼ばれる関数（簡易版）|
|sa_sigaction        |siginfo_t を使う詳細なハンドラ（SA_SIGINFO フラグを有効にすると使用可能）|
|sa_mask	          |  ハンドラ実行中にブロックするシグナルのセット|
|sa_flags	        |ハンドラの動作を制御するフラグ|

#### 表
|項目           |struct sigaction                        |sigset_t                                  |
|---------------|----------------------------------------|------------------------------------------|
|目的           |シグナルを受けたときの動作を設定	        |シグナルのブロック・解除を管理               |
|対象           |特定のシグナル（SIGINT, SIGTERM など）	   |複数のシグナル をまとめて管理                |
|主な関数       |sigaction()	                         |sigemptyset(), sigaddset(), sigprocmask()  |
|よく使う場面	|シグナルハンドラーを設定したいとき	        |シグナルをブロック・解除したいとき             |


---

## 質問
### クライアントコード

```
if ((c & (1 << bit)) != 0):
```
- Q1 : この条件式は、文字のビットをどのようにチェックしているのですか？
> A1 : 

### サーバーコード
```
c |= (1 << bit);
```
- Q2 : この行は、受信したシグナルビットから文字をどのように再構成しているのですか？
> A2 : 

- Q : `sa.sa_handler = signal_handler;`に引数が指定されていないのはなぜ？
```
void	signal_handler(int signal)
{
    ...
}

int	main(int ac, char **av)
{
    ...
	sa.sa_handler = signal_handler;
    ...
}
```
> A : 構造体である`sa.sa_handler`はシグナルを受け取った時に実行される関数のポインタで、型: `void (*sa_handler)(int)`で宣言されています。したがって、引数を受けることができ、そして`signal_handler`関数のポインタを格納することで、「シグナルが来た時に引数を受け取り`signal_handler`関数に渡す」という条件がそろう

### その他
- Q3 : `EXIT_FAILURE`とは何？
```
void	error_handler(const char *msg, const char *details)
{
    ...
	exit(EXIT_FAILURE);
}
```
> A3 : exit関数の戻り値で`EXIT_SUCCESS`,`EXIT_FAILURE`があり、それぞれ`0`,`1`が割り当てられている定数である。

- Q4 : '\t','\r'は何？
```
int	ft_isspace(int c)
{
	return (c == ' ' || (c >= '\t' && c <= '\r'));
}
```
> A4 : asciiで、スペース (' '), タブ ('\t'), 改行 ('\n'), 復帰 ('\r'), 垂直タブ ('\v'), フォームフィード ('\f')

- Q : struct sigactionとsigset_t関係性は何?
```
    void (*sa_handler)(int);
    void (*sa_sigaction)(int, siginfo_t *, void *);
    sigset_t sa_mask;
    int sa_flags;

```
> A : どちらも構造体でsigset_tはstruct sigactionに含まれている。
---
