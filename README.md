# Minitalk

## Project Structure
```
.
├── Makefile
├── all_libft
│   ├── Makefile
│   ├── include
│   │   ├── ft_printf.h
│   │   ├── get_next_line_bonus.h
│   │   └── libft.h
│   └── src
│       ├── ft_printf
│       ├── gnl
│       └── libft
│           ├── bool_atoi.c
│           ├── error_handler.c
│           └── ft_isspace.c
├── include
│   ├── minitalk.h
│   └── minitalk_bonus.h
└── src
    ├── client.c
    ├── client_bonus.c
    ├── server.c
    └── server_bonus.c

8 directories, 66 files
```

## 概要
```
シグナル通信を利用してクライアントサーバー型のアプリケーションを作る
```
### １．クライアントサーバー型

> それぞれが個別のプロセスとなる２つの実行ファイルを作成
- Makefileで二つの実行ファイルを作成する
> プロセスが分かれているため（シングルプロセスではないため）プロセス間の通信が必要
- 今回はシグナル通信を使用する
- プロセス間通信の方法はシグナルの他にも、`パイプ`,`ソケット通信`,`メッセージキュー`などがある。

### ２．シグナル

- シグナルは64種類あり、`kill -l`で一覧を出力できる
- 今回の課題では、ユーザーに完全に解放されている`(10)SIGUSR1`、`(12)SIGUSR2`のみを利用する。

### ３．シリアル通信的通信
- 二進数の0・1をそれぞれSIGUSR1・SIGUSR2に割り当てて通信する
```
<例>
char型は１バイトで８ビット
const char c = 'A'
A == 0x41(01000001) 
Aを送るにはバイナリを８回１ビットずつ送ればよい。
```

### ４．割り込み

#### クライアント
- 文字を１ビットずつ２種類のシグナルを利用して送信
- kill(システムコール)を利用する

#### サーバー
- シグナルを受け取り、文字を復元する
- signalまたはsigactionを利用する

> ####  signal/sigaction
- 通常シグナルがプロセスに届く(今回の場合はサーバーに届く)とデフォルトアクションが発生し、プロセス終了が実行される。
- このプロセス終了に割り込み、シグナルを横取りする形で別の動作をさせるのがsignal/sigaction。
- sigactionにsignal_handlerを設定することで受け取ったシグナルに応じて元の文字にデコードしていくことができる

### ５．データ欠損の追求
#### 1. signal関数を使ったと時の問題点
- 割り込み中にシグナルが発生すると、割り込みの割り込みが発生し、文字化けが起きる
#### 2. sigactionを使うことで対応する
- SIGUSR1とSIGUSR2の相互の割り込みを禁止できる
#### 3. sigaction関数でも解消されない(割り込み禁止なのに文字化けする)
- ブロックされたシグナルの行方を追う
#### 4. ブロックされたシグナル
- 複数のシグナルが発生し、そのシグナルがブロックされていた(処理待ちシグナルが溜まっていた)場合、ブロック解除後に配送されるのはシグナルひとつだけになる。カーネルではシグナルの待機は一つまでとなっているそう
- 複数のシグナルが処理待ち状態になった場合、配送される順序は不定(SIGUSR1 - SIGUSR2の順でシグナルが送信されてきたとき、一つ目の出力がSIGUSR1になるとは限らない)
> これらのことからシグナルを貯めるのは難しいとわかる。
#### 5. まとめられたシグナル
```
[コラム]
シグナル送信元のpidを調べると０から送られていることがある。
    > これはシグナルがまとめられた時のOSXの不思議な挙動
    > Linuxもまとめられるがpidは一つ目の送信元となる
```
- シグナルはまとめられた時点でデータは欠損してしまう。
>  #### 対策
- sleepを入れてごまかす > 環境や状況によって適正なsleep量が変わる
- bitごとにACKを返信させる > かなり堅牢な通信
```
[堅牢通信]
サーバーは、クライアントに受信したことをビットごとに返事する
クライアントは返事が来たことを確認して次のビットを送信する
```
---

## ビルドとクリーンコマンド
### ビルド
- 全ビルド: `make`
- ボーナス付きビルド: `make bonus`

### クリーン
- 中間ファイル削除: `make clean`
- 完全クリーンアップ: `make fclean`

### 再ビルド
- 全て再ビルド: `make re`

---

## 関数
- **`kill`**: 指定されたプロセスにシグナルを送信します。
- **`error_handler`**: プログラム内でエラーが発生した際に処理とメッセージ表示を行う関数。
- **`usleep`**: プログラムの実行を指定時間（マイクロ秒単位）停止します。
- **`getpid`**: 現在のプロセスID（PID）を取得します。
- **`sigemptyset`**: シグナルマスク（シグナルセット）を空に初期化します。
- **`sigaddset`**: シグナルマスクに特定のシグナルを追加します。
- **`sigaction`**: 特定のシグナルを受信した際のハンドラーを設定します。
- **`pause`**: シグナルを受信するまでプログラムを一時停止します。

---

## 用語
- **PID**: OSが各プロセスを一意に識別するために割り当てる番号。
- **シグナル**: UNIX/Linux環境でプロセス間通信やイベント通知を行う仕組み。ソフトウェア割り込みとして動作します。
- **システムコール**: ユーザープログラムがOSのカーネル機能を利用するためのインターフェース。例: ファイル操作、プロセス管理、ネットワーク通信。
- **シグナルマスク**: 特定のシグナルを一時的にブロック（受信しないように）する仕組み。

---

## メモ
### シグナル
シグナルは、UNIX/Linuxにおけるソフトウェア割り込みの一種で、プロセス間の通信やシステムからプロセスへの通知に使用されます。例えば、子プロセスの終了通知やエラーの通知などに利用されます。

### システムコール
システムコールは、ユーザープログラムがOSカーネルのサービスを要求するインターフェースで、ファイルアクセスやプロセス管理、入出力操作を実現します。

### シグナルマスク
シグナルマスクを使うことで、特定のシグナルを一時的にブロックし、重要なコードが中断されることを防ぎます。

### 構造体
struct sigactionは、UNIX系OS（Linux, macOS など）で シグナル処理 を設定するための構造体です。

例
'''
struct sigaction {
    void (*sa_handler)(int);   /* シグナルハンドラ関数のポインタ */
    void (*sa_sigaction)(int, siginfo_t *, void *); /* 詳細情報を取得できるハンドラ */
    sigset_t sa_mask;          /* シグナルハンドラ実行中にブロックするシグナルのマスク */
    int sa_flags;              /* シグナルハンドラの動作を決定するフラグ */
};
'''

フィールドの説明
フィールド名        説明
sa_handler          シグナルを受信したときに呼ばれる関数（簡易版）
sa_sigaction        siginfo_t を使う詳細なハンドラ（SA_SIGINFO フラグを有効にすると使用可能）
sa_mask	            ハンドラ実行中にブロックするシグナルのセット
sa_flags	        ハンドラの動作を制御するフラグ

---

## 質問
### クライアントコード
```c
if ((c & (1 << bit)) != 0):
```
- 質問: この条件式は、文字のビットをどのようにチェックしているのですか？

### サーバーコード
```c
c |= (1 << bit);
```
- 質問: この行は、受信したシグナルビットから文字をどのように再構成しているのですか？

---