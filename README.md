# Minitalk

## 目次
- 構成
- 課題条件
- 概要
- 実行
- 使用関数
- 用語
- ビット操作
- 質問
- メモ

  
## 構成
```
.
├── Makefile
├── all_libft
│   ├── Makefile
│   ├── include
│   │   ├── ft_printf.h
│   │   ├── get_next_line_bonus.h
│   │   └── libft.h
│   └── src
│       ├── ft_printf
│       ├── gnl
│       └── libft
│           ├── bool_atoi.c
│           ├── error_handler.c
│           └── ft_isspace.c
├── include
│   ├── minitalk.h
│   └── minitalk_bonus.h
└── src
    ├── client.c
    ├── client_bonus.c
    ├── server.c
    └── server_bonus.c

8 directories, 66 files
```

## 課題条件
- サーバーはPIDを表示する
- クライアントは２つのパラメータを受け取る
- 100文字は１秒以内に表示
- 複数クライアントから受信
- ボーナスはメッセージに対して返信する
- ボーナスはユニコード対応

## 概要
```
シグナル通信を利用してクライアントサーバー型のアプリケーションを作る
```
### １．クライアントサーバー型

> それぞれが個別のプロセスとなる２つの実行ファイルを作成
- Makefileで二つの実行ファイルを作成する
> プロセスが分かれているため（シングルプロセスではないため）プロセス間の通信が必要
- 今回はシグナル通信を使用する
- プロセス間通信の方法はシグナルの他にも、`パイプ`,`ソケット通信`,`メッセージキュー`などがある。

### ２．シグナル

- シグナルは64種類あり、`kill -l`で一覧を出力できる
- 今回の課題では、ユーザーに完全に解放されている`(10)SIGUSR1`、`(12)SIGUSR2`のみを利用する。

### ３．シリアル通信的通信
- 二進数の0・1をそれぞれSIGUSR1・SIGUSR2に割り当てて通信する
```
<例>
char型は１バイトで８ビット
const char c = 'A'
A == 0x41(01000001) 
Aを送るにはバイナリを８回１ビットずつ送ればよい。
```

### ４．割り込み

#### クライアント
- 文字を１ビットずつ２種類のシグナルを利用して送信
- kill(システムコール)を利用する

#### サーバー
- シグナルを受け取り、文字を復元する
- signalまたはsigactionを利用する

> ####  signal/sigaction
- 通常シグナルがプロセスに届く(今回の場合はサーバーに届く)とデフォルトアクションが発生し、プロセス終了が実行される。
- このプロセス終了に割り込み、シグナルを横取りする形で別の動作をさせるのがsignal/sigaction。
- sigactionにsignal_handlerを設定することで受け取ったシグナルに応じて元の文字にデコードしていくことができる

### ５．データ欠損の追求
#### 1. signal関数を使ったと時の問題点
- 割り込み中にシグナルが発生すると、割り込みの割り込みが発生し、文字化けが起きる
#### 2. sigactionを使うことで対応する
- SIGUSR1とSIGUSR2の相互の割り込みを禁止できる
#### 3. sigaction関数でも解消されない(割り込み禁止なのに文字化けする)
- ブロックされたシグナルの行方を追う
#### 4. ブロックされたシグナル
- 複数のシグナルが発生し、そのシグナルがブロックされていた(処理待ちシグナルが溜まっていた)場合、ブロック解除後に配送されるのはシグナルひとつだけになる。カーネルではシグナルの待機は一つまでとなっているそう
- 複数のシグナルが処理待ち状態になった場合、配送される順序は不定(SIGUSR1 - SIGUSR2の順でシグナルが送信されてきたとき、一つ目の出力がSIGUSR1になるとは限らない)
> これらのことからシグナルを貯めるのは難しいとわかる。
#### 5. まとめられたシグナル
```
[コラム]
シグナル送信元のpidを調べると０から送られていることがある。
    > これはシグナルがまとめられた時のOSXの不思議な挙動
    > Linuxもまとめられるがpidは一つ目の送信元となる
```
- シグナルはまとめられた時点でデータは欠損してしまう。
>  #### 対策
- sleepを入れてごまかす > 環境や状況によって適正なsleep量が変わる
- bitごとにACKを返信させる > かなり堅牢な通信
```
[堅牢通信]
サーバーは、クライアントに受信したことをビットごとに返事する
クライアントは返事が来たことを確認して次のビットを送信する
```

---

## ビルドとクリーンコマンド
### ビルド
- ビルド: `make`
- ボーナスビルド: `make bonus`

### クリーン
- 中間ファイル削除: `make clean`
- 完全クリーンアップ: `make fclean`

### 再ビルド
- 再ビルド: `make re`

---

## 使用関数
- **`kill`**: 指定されたプロセスにシグナルを送信します。
- **`error_handler`**: プログラム内でエラーが発生した際に処理とメッセージ表示を行う関数。
- **`usleep`**: プログラムの実行を指定時間（マイクロ秒単位）停止します。
- **`getpid`**: 現在のプロセスID（PID）を取得します。
- **`sigemptyset`**: シグナルマスク（シグナルセット）を空に初期化します。
- **`sigaddset`**: シグナルマスクに特定のシグナルを追加します。
- **`sigaction`**: 特定のシグナルを受信した際のハンドラー（動作）を設定します。
- **`pause`**: シグナルを受信するまで待機します。
- **`write`**:標準出力に書き込む
- **`exit`**:プログラムを即座に終了する。
#### オリジナル関数
- **`ft_printf`**:printfの模擬関数
- **`ft_putstr_fd`**:文字列出力
- **`ft_putchar_fd`**:単語出力
- **`bool_atoi`**:変換成功の結果を返し、変換後の値をメモリに格納する

> ### sigemptyset
```
int sigemptyset(sigset_t *set);
```
- set : 初期化するシグナルセット
> ### sigaddset
```
int sigaddset(sigset_t *set, int signum);
```
- set : シグナルセット
- signum : 追加するシグナル（例：SIGINT）
> ### sigaction
```
int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);
```
- signum : 設定するシグナル（例：SIGINT）
- act : 新しい動作
- oldact : 以前の動作を保存（不要なら NULL）
> ### kill
```
int kill(pid_t pid, int sig);
```
- pid : シグナルを送るプロセスのID（getpid() で取得可能）
- sig : 送るシグナル（例：SIGKILL）
> ### getpid
```
pid_t getpid(void);
```
> ### pause
```
int pause(void);
```
> ### usleep
```
int usleep(useconds_t usec);
```
- usec : 待機する時間（マイクロ秒）
> ### exit
```
void exit(int status);
```
- status : 終了コード（0なら正常終了、1以上なら異常終了）

---

## 構造体
- `struct sigaction`は特定のシグナルを受け取ったときの動作を設定するために使います。（どの関数を実行するか、シグナルを無視するか、デフォルト動作にするか など）
- `siginfo_t`はシグナルに関する追加情報を格納する構造体でsa_sigaction の引数として使われる。
- `sigset_t` はシグナルをビットマスクとして管理する（複数のシグナルをまとめて管理する）ための型です。実際には、ビットフィールドや整数型の配列として定義されており、各ビットが特定のシグナルを示し、システムによって sigset_t の内部構造は異なります。シグナルセットを操作するための関数が提供されており、特定のシグナルをまとめてブロックしたり、処理を制御したりすることが可能になります。

### struct sigaction
```
struct sigaction {
    void (*sa_handler)(int);
    void (*sa_sigaction)(int, siginfo_t *, void *);
    sigset_t sa_mask;
    int sa_flags;
};
```
- `sa_handler` : シグナルを受け取ったときに実行するシグナルハンドラ関数を指定する。
```
シグナル番号（int 型の引数）を受け取り、適切な処理を行う関数を登録する。例: SIGUSR1 を受け取ったときに signal_handler を実行するよう設定できる。
```
- `sa_sigaction` : より詳細な情報を取得できるシグナルハンドラ関数を指定する。
```
siginfo_t 構造体を使って、シグナルの発生原因や送信元のプロセスIDなどの情報を取得できる。
sa_flags に SA_SIGINFO を設定すると、この関数が sa_handler の代わりに呼ばれる。
```
- `siginfo_t` : シグナルに関する追加情報を保持する構造体。
```
送信元のプロセスID、実際に送られた値、シグナルの発生理由などを含む。
sa_sigaction を使う場合に引数として渡される。
```
- `sigset_t` : シグナルの集合を表すデータ型。
```
シグナルのブロックや解除を管理するために使われる。
sigemptyset() や sigaddset() などの関数で操作できる。
```
- `sa_mask` : ハンドラ関数が実行されている間、一時的に ブロック（無効化）するシグナルの集合 を指定する。
```
これにより、ハンドラ実行中に他のシグナルが割り込むのを防ぐことができる。
```
- `sa_flags` : シグナルハンドラの動作を決める フラグ を設定
```
例えば、SA_RESTART（システムコールの再開）、SA_SIGINFO（詳細情報取得）などのオプションがある。
```

### siginfo_t
```
typedef struct {
    int si_signo;
    int si_errno;
    int si_code;
    union {
        int _pad[29];
    } _sifields;
} siginfo_t;
```
- `si_signo` : シグナル番号
```
どのシグナルが発生したかを表します。
例えば：
SIGINT（Ctrl+C の割り込み）
SIGSEGV（セグメンテーションフォルト）
SIGKILL（強制終了）
などのシグナル番号が格納されます。
```
- `si_errno` : エラー番号
```
シグナルに関連するエラー番号を保持します。
errnoの値と同じ意味を持ちます（EFAULT など）。
エラーがない場合は0になります。
```
- `si_code` : シグナルの原因
```
シグナルが発生した原因や発生元を示します。
例えば：

SI_KERNEL → カーネルによって発生
SI_USER → ユーザーがkill()で送信
SI_QUEUE → sigqueue()による送信
SI_TIMER → タイマーの満了
SI_ASYNCIO → 非同期I/Oの完了
など、シグナルの発生理由を知ることができます。
```
- `_sifields` : 追加情報
```
unionを使用して、シグナルの種類に応じた詳細情報を格納します。
システムやシグナルの種類によって異なるデータを持ちます。
一般的にsiginfo_tは以下のようにシグナルごとの情報を持ちます。
```
- `union` : 一度に1つのメンバしか格納できないデータ構造
```
メモリ上ではすべてのメンバが同じアドレスを共有します。
複数のデータ型を同じメモリ領域に格納できる。
最大サイズのメンバ分のメモリだけが確保される。
どのメンバが有効かはプログラム側で管理する必要がある。
例：
union Data {
    int i;
    float f;
};

int main() {
    union Data data;
    data.i = 10;
    printf("data.i = %d\n", data.i);//一回目
    data.f = 3.14;
    printf("data.f = %.2f\n", data.f);
    printf("data.i = %d\n", data.i);//二回目
    return 0;
}
上のようなプログラムの場合以下のように出力される
data.i = 10
data.f = 3.14
data.i = -12345678  ← 予測不能な値
二回目のdata.iの値が正しくないのは、data.f = 3.14;によって上書きされているから。
通常の構造体ではメンバごとに別のメモリを確保するが、unionはこのようにメンバが同じメモリ領域を使用するため異なる型で宣言するとデータが崩れるし、メモリを上書きして利用するため同じ型でも複数のデータを保持しておくことはできない。
```
- `_pad[29]` : パディング（詰め物）用の配列
```
なぜ29というサイズの配列があるのか？
_sifieldsはシグナルの種類ごとに異なるデータを格納するためのunion。
しかし、システムやCPUによってsiginfo_tのサイズが変わると困る。
そのため、固定サイズの配列_pad[29]を用意し、データの大きさを統一している。
```

### sigset
```
[Linux（glibc）]

typedef struct {
    unsigned long __val[_SIGSET_NWORDS];
} sigset_t;
```
- `__val` : シグナルのセットを保持するためのビット配列
```
各ビットが対応するシグナルを表し、1 ならセットされている（ブロックされている）、0 ならセットされていない。
```
- `_SIGSET_NWORDS` : sigset_tを構成する`unsigned long`の配列の要素数
```
システムのシグナルの最大数に応じて異なるが、多くの場合 64 ビット環境では 2 になる。
これにより、すべてのシグナルを表すのに十分なビット数を確保できる。
```
#### 使用例
- sigemptyset: シグナルセットを空にする。
```
[例文]
sigset_t set;
sigemptyset(&set);

[今回のプログラムでの例]
struct sigaction {
    ...
    sigset_t sa_mask;
    ...
};

typedef struct sigaction	t_sa;

t_sa	sa;

sigemptyset(&sa.sa_mask);
```
struct sigactionを挟んでsigemptyset(&set);と同様のことを行っているため少し複雑に見える。

---

## 用語
- **PID** : OSが各プロセスを一意に識別するために割り当てる番号。
- **シグナル** : UNIX/Linux環境でプロセス間通信やイベント通知を行う仕組み。ソフトウェア割り込みとして動作します。
- **システムコール** : ユーザープログラムがOSのカーネル機能を利用するためのインターフェース。例: ファイル操作、プロセス管理、ネットワーク通信。
- **シグナルマスク** : 特定のシグナルを一時的にブロック（受信しないように）する仕組み。
- **シグナルセット** : 複数のシグナルをまとめて管理するデータ構造
- **ビットマスク** : ビット演算を利用して、特定のビットの操作（ON/OFF/切り替えなど）を行う手法
- **ビットフィールド** :  構造体のメンバーをビット単位で管理する方法。通常、変数は1バイト（8ビット）単位で確保されますが、ビットフィールドを使うと、必要なビット数だけを指定して格納できる。
- **ハンドラ** : 特定のイベントや条件が発生したときに自動的に呼び出される関数のこと
- **シグナルハンドラ** : シグナルを受信した際に実行される関数
- **ブロック** : シグナルが送信された際に、そのシグナルを一時的に無視（処理を遅延）すること、シグナルがブロックされている間、そのシグナルは受け取られても処理されず、後で処理されることになります。



---

## ビット操作
- このプログラムではプロセス間通信を１ビットごとに行っているため、以下のようなビット単位の操作が求められる。
```
c |= (1 << bit);
```
```
if ((c & (1 << bit)) != 0)
```
> ### (1 << bit)について
- bit番目のビットだけが1になる
- ビットシフト 1 << bit を使うと、1をbit回左にずらします。
```
例えば、bit = 3 の場合:
1 << 3  →  00000001 (1) を左に 3 ビットシフト
            →  00001000 (8)
```
- bit の位置(0から始まって4番目)に1がセットされた数値が得られます。

> ### c |= (1 << bit)について
- cのbit番目を1にする
- c = c | (1 << bit)
- ビット OR (|=) を使うことで、bit番目を1にします。
```
例えば、c = 00000010 (2) のとき、bit = 3 の場合:
c           = 00000010  (2)
1<<3    = 00001000  (8)
----------------------------
OR        = 00001010  (10)  // 0000010の情報を保持しつつbit=3の位置が1になった
```
- このようにcのbit番目のビットを1にすることができます。
- 同じ条件でORが無い場合、1<<3 = 00001000 (8) だけがcに挿入されて、元の情報が消えてしまう。

> ### 流れ
- このコードでは、SIGUSR1 を受け取るたびに c に 1 ビットずつ蓄積 しています。
```
例:SIGUSR1を8回受信する場合
c |= (1 << 0)   c = 00000001
c |= (1 << 1)   c = 00000011
c |= (1 << 2)   c = 00000111
c |= (1 << 3)   c = 00001111
c |= (1 << 4)   c = 00011111
c |= (1 << 5)   c = 00111111
c |= (1 << 6)   c = 01111111
c |= (1 << 7)   c = 11111111  (255, 'ÿ' などの文字として解釈される)
```
- 8回のビット設定が完了すると c が 1 バイトの文字となり、write(1, &c, 1); で標準出力に出力されます。

> ### c & (1 << bit)について
- 文字cのbit番目のビットが1であるかどうかを確認する 
- cと(1 << bit)のビット論理積(AND)を計算
```
例えば、c = 10101100（2進数で 172）で、bit = 3 の場合：
c              = 10101100
1 << 3     = 00001000
----------------------------------
AND         = 00001000  // 3番目のビットだけが残り、他は 0
```
- 00001000は０ではないと判断できる
```
逆に、c = 10100100（2進数で 164）で、bit = 3 の場合：
c              = 10100100
1 << 3     = 00001000
----------------------------------
AND         = 00000000  // 全て0
```
- 00000000は０だと判断できる
- これらのifを元にSIGUSR1とSIGUSR2を送信する。

## 質問
### クライアントコード

- #### Q1 : この条件式は、文字のビットをどのようにチェックしているのですか？
```
if ((c & (1 << bit)) != 0):
```
> A1 : 

### サーバーコード

- #### Q2 : この行は、受信したシグナルビットから文字をどのように再構成しているのですか？
```
c |= (1 << bit);
```
> A2 : static int cによってビットを保持し、１バイト分揃った時点で標準出力をしている

- #### Q : `sa.sa_handler = signal_handler;`に引数が指定されていないのはなぜ？
```
void	signal_handler(int signal)
{
    ...
}

int	main(int ac, char **av)
{
    ...
	sa.sa_handler = signal_handler;
    ...
}
```
> A : 構造体である`sa.sa_handler`はシグナルを受け取った時に実行される関数のポインタで、型: `void (*sa_handler)(int)`で宣言されています。したがって、引数を受けることができ、そして`signal_handler`関数のポインタを格納することで、「シグナルが来た時に引数を受け取り`signal_handler`関数に渡す」という条件がそろう

### その他
- #### Q3 : `EXIT_FAILURE`とは何？
```
void	error_handler(const char *msg, const char *details)
{
    ...
	exit(EXIT_FAILURE);
}
```
> A3 : exit関数の戻り値で`EXIT_SUCCESS`,`EXIT_FAILURE`があり、それぞれ`0`,`1`が割り当てられている定数である。

- #### Q4 : '\t','\r'は何？
```
int	ft_isspace(int c)
{
	return (c == ' ' || (c >= '\t' && c <= '\r'));
}
```
> A4 : asciiで、スペース (' '), タブ ('\t'), 改行 ('\n'), 復帰 ('\r'), 垂直タブ ('\v'), フォームフィード ('\f')

- #### Q :sigactionやpause はシグナルの受信をどうやって認知しているの？
> シグナルの受信をカーネルが管理している仕組みを利用して認知します。

---
---
---
---
## メモ
### シグナル
- シグナルは、UNIX/Linuxにおけるソフトウェア割り込みの一種で、プロセス間の通信やシステムからプロセスへの通知に使用されます。例えば、子プロセスの終了通知やエラーの通知などに利用されます。

### システムコール
- システムコールは、ユーザープログラムがOSカーネルのサービスを要求するインターフェースで、ファイルアクセスやプロセス管理、入出力操作を実現します。

### シグナルマスク
- シグナルマスクを使うことで、特定のシグナルを一時的にブロックし、重要なコードが中断されることを防ぎます。
